{"version":3,"file":"ItemImageService.js","sourceRoot":"","sources":["../../../src/api/services/ItemImageService.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2017-2018, The Particl Market developers\n// Distributed under the GPL software license, see the accompanying\n// file COPYING or https://github.com/particl/particl-market/blob/develop/LICENSE\n\nimport * as Bookshelf from 'bookshelf';\nimport * as _ from 'lodash';\nimport { inject, named } from 'inversify';\nimport { Logger as LoggerType } from '../../core/Logger';\nimport { Types, Core, Targets } from '../../constants';\nimport { validate, request } from '../../core/api/Validate';\nimport { NotFoundException } from '../exceptions/NotFoundException';\nimport { ItemImageRepository } from '../repositories/ItemImageRepository';\nimport { ItemImage } from '../models/ItemImage';\nimport { ItemImageCreateRequest } from '../requests/ItemImageCreateRequest';\nimport { ItemImageDataCreateRequest } from '../requests/ItemImageDataCreateRequest';\nimport { ItemImageUpdateRequest } from '../requests/ItemImageUpdateRequest';\nimport { ItemImageDataService } from './ItemImageDataService';\nimport { ImageProcessing } from '../../core/helpers/ImageProcessing';\nimport { ImageTriplet } from '../../core/helpers/ImageTriplet';\nimport { ImageFactory } from '../factories/ImageFactory';\nimport { ImageVersions } from '../../core/helpers/ImageVersionEnumType';\nimport { MessageException } from '../exceptions/MessageException';\nimport { ImageDataProtocolType } from '../enums/ImageDataProtocolType';\nimport { ListingItemTemplate } from '../models/ListingItemTemplate';\nimport { ImagePostUploadRequest } from '../requests/ImagePostUploadRequest';\nimport { HashableObjectType } from '../../api/enums/HashableObjectType';\nimport * as fs from 'fs';\nimport { ObjectHash } from '../../core/helpers/ObjectHash';\n\nexport class ItemImageService {\n\n    public log: LoggerType;\n\n    constructor(\n        @inject(Types.Service) @named(Targets.Service.ItemImageDataService) public itemImageDataService: ItemImageDataService,\n        @inject(Types.Repository) @named(Targets.Repository.ItemImageRepository) public itemImageRepo: ItemImageRepository,\n        @inject(Types.Factory) @named(Targets.Factory.ImageFactory) public imageFactory: ImageFactory,\n        @inject(Types.Core) @named(Core.Logger) public Logger: typeof LoggerType\n    ) {\n        this.log = new Logger(__filename);\n    }\n\n    public async findAll(): Promise<Bookshelf.Collection<ItemImage>> {\n        return this.itemImageRepo.findAll();\n    }\n\n    public async findOne(id: number, withRelated: boolean = true): Promise<ItemImage> {\n        const itemImage = await this.itemImageRepo.findOne(id, withRelated);\n        if (itemImage === null) {\n            this.log.warn(`ItemImage with the id=${id} was not found!`);\n            throw new NotFoundException(id);\n        }\n        return itemImage;\n    }\n\n    /**\n     * create(), but get data from a local file instead.\n     *\n     * @param imageFile\n     * @param {ListingItemTemplate} listingItemTemplate\n     * @returns {Promise<ItemImage>}\n     */\n    @validate()\n    public async createFromFile(imageFile: any, listingItemTemplate: ListingItemTemplate): Promise<ItemImage> {\n        // TODO: how am i supposed to know what imageFile contains? add type to it\n\n        // Read the file data in\n        const dataStr = fs.readFileSync(imageFile.path, 'base64');\n        // this.log.error('dataStr = ' + dataStr);\n\n        // find listing item template\n        // this.log.debug('imageFile.mimetype = ' + imageFile.mimetype);\n        // find related itemInformation\n\n        const itemInformation = await listingItemTemplate.related('ItemInformation').toJSON();\n\n        const itemImageDataCreateRequest = {\n            protocol: ImageDataProtocolType.LOCAL,\n            encoding: 'BASE64',\n            data: dataStr,\n            dataId: imageFile.fieldname, // replaced with local url in factory\n            imageVersion: ImageVersions.ORIGINAL.propName,\n            originalMime: imageFile.mimetype,\n            originalName: imageFile.originalname\n        };\n\n        const itemImageCreateRequest = {\n            item_information_id: itemInformation.id,\n            data: [itemImageDataCreateRequest]\n        } as ItemImageCreateRequest;\n\n        return await this.create(itemImageCreateRequest);\n    }\n\n    @validate()\n    public async create( @request(ItemImageCreateRequest) data: ItemImageCreateRequest): Promise<ItemImage> {\n        const startTime = new Date().getTime();\n\n        const body = JSON.parse(JSON.stringify(data));\n\n        // this.log.debug('create image, body: ', JSON.stringify(body, null, 2));\n\n        // extract and remove related models from request\n        const itemImageDatas: ItemImageDataCreateRequest[] = body.data;\n        delete body.data;\n\n        const protocols = Object.keys(ImageDataProtocolType)\n            .map(key => (ImageDataProtocolType[key]));\n        // this.log.debug('protocols: ', protocols);\n\n        const itemImageDataOriginal = _.find(itemImageDatas, (imageData) => {\n            return imageData.imageVersion === ImageVersions.ORIGINAL.propName;\n        });\n        // this.log.debug('itemImageDataOriginal: ', itemImageDataOriginal);\n\n        // use the original image version to create a hash for the ItemImage\n        body.hash = ObjectHash.getHash(itemImageDataOriginal, HashableObjectType.ITEMIMAGEDATA_CREATEREQUEST);\n\n        // if the request body was valid we will create the itemImage\n        const itemImage = await this.itemImageRepo.create(body);\n\n\n        if (itemImageDataOriginal) {\n\n            if (_.isEmpty(itemImageDataOriginal.protocol) ||  protocols.indexOf(itemImageDataOriginal.protocol) === -1) {\n                this.log.warn(`Invalid protocol <${itemImageDataOriginal.protocol}> encountered.`);\n                throw new MessageException('Invalid image protocol.');\n            }\n\n            // then create the imageDatas from the given original data\n            if (!_.isEmpty(itemImageDataOriginal.data)) {\n                const toVersions = [ImageVersions.LARGE, ImageVersions.MEDIUM, ImageVersions.THUMBNAIL];\n                const imageDatas: ItemImageDataCreateRequest[] = await this.imageFactory.getImageDatas(itemImage.Id, itemImageDataOriginal, toVersions);\n\n                // save all image datas\n                for (const imageData of imageDatas) {\n                    await this.itemImageDataService.create(imageData);\n                }\n\n                // finally find and return the created itemImage\n                const newItemImage = await this.findOne(itemImage.Id);\n                // this.log.debug('saved image:', JSON.stringify(newItemImage.toJSON(), null, 2));\n\n                this.log.debug('itemImageService.create: ' + (new Date().getTime() - startTime) + 'ms');\n                return newItemImage;\n            } else {\n                this.log.debug('itemImageService.create: ' + (new Date().getTime() - startTime) + 'ms');\n                return itemImage;\n            }\n        } else {\n            throw new MessageException('Original image data not found.');\n        }\n    }\n\n    @validate()\n    public async update(id: number, @request(ItemImageUpdateRequest) data: ItemImageUpdateRequest): Promise<ItemImage> {\n\n        const body = JSON.parse(JSON.stringify(data));\n\n        // extract and remove related models from request\n        const itemImageDatas: ItemImageDataCreateRequest[] = body.data;\n        delete body.data;\n\n        // find the existing one without related\n        const itemImage = await this.findOne(id, false);\n\n        const protocols = Object.keys(ImageDataProtocolType)\n            .map(key => (ImageDataProtocolType[key]));\n\n        const itemImageDataOriginal = _.find(itemImageDatas, (imageData) => {\n            return imageData.imageVersion === ImageVersions.ORIGINAL.propName;\n        });\n\n        // use the original image version to create a hash for the ItemImage\n        body.hash = ObjectHash.getHash(itemImageDataOriginal, HashableObjectType.ITEMIMAGEDATA_CREATEREQUEST);\n\n        if (itemImageDataOriginal) {\n\n            if (_.isEmpty(itemImageDataOriginal.protocol) || protocols.indexOf(itemImageDataOriginal.protocol) === -1) {\n                this.log.warn(`Invalid protocol <${itemImageDataOriginal.protocol}> encountered.`);\n                throw new MessageException('Invalid image protocol.');\n            }\n\n            // set new values\n            itemImage.Hash = body.hash;\n\n            // update itemImage record\n            const updatedItemImage = await this.itemImageRepo.update(id, itemImage.toJSON());\n\n            // this.log.debug('updatedItemImage', JSON.stringify(updatedItemImage, null, 2));\n            // find and remove old related ItemImageDatas\n            const oldImageDatas = updatedItemImage.related('ItemImageDatas').toJSON();\n            for (const imageData of oldImageDatas) {\n                await this.itemImageDataService.destroy(imageData.id);\n            }\n\n            // then create new imageDatas from the given original data\n            if (!_.isEmpty(itemImageDataOriginal)) {\n                const toVersions = [ImageVersions.LARGE, ImageVersions.MEDIUM, ImageVersions.THUMBNAIL];\n                const imageDatas: ItemImageDataCreateRequest[] = await this.imageFactory.getImageDatas(itemImage.Id, itemImageDataOriginal, toVersions);\n\n                // create new image datas\n                for (const imageData of imageDatas) {\n                    const createdImageData = await this.itemImageDataService.create(imageData);\n                    this.log.debug('createdImageData: ', createdImageData.id);\n                }\n            }\n\n            // finally find and return the updated itemImage\n            const newItemImage = await this.findOne(id);\n            return newItemImage;\n        } else {\n            throw new MessageException('Original image data not found.');\n        }\n    }\n\n    public async destroy(id: number): Promise<void> {\n        await this.itemImageRepo.destroy(id);\n    }\n}\n"]}