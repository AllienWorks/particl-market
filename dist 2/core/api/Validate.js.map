{"version":3,"file":"Validate.js","sourceRoot":"","sources":["../../../src/core/api/Validate.ts"],"names":[],"mappings":";AAAA,yDAAyD;AACzD,mEAAmE;AACnE,iFAAiF;;;AAEjF;;;;;;;;GAQG;AAEH,4BAA0B;AAK1B,MAAM,kBAAkB,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC;AAOrD;;;;GAIG;AACU,QAAA,OAAO,GAAG,CAAC,WAA+B,KAAK,CAAC,MAAc,EAAE,WAA4B,EAAE,cAAsB;IAC7H,MAAM,yBAAyB,GAAuB,OAAO,CAAC,cAAc,CAAC,kBAAkB,EAAE,MAAM,EAAE,WAAW,CAAC,IAAI,EAAE,CAAC;IAC5H,yBAAyB,CAAC,IAAI,CAAC;QAC3B,OAAO,EAAE,WAAW;QACpB,KAAK,EAAE,cAAc;KACxB,CAAC,CAAC;IACH,OAAO,CAAC,cAAc,CAAC,kBAAkB,EAAE,yBAAyB,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;AAC/F,CAAC,CAAC;AAEF;;;;GAIG;AACU,QAAA,OAAO,GAAG,CAAC,WAA+B,KAAK,CAAC,MAAc,EAAE,WAA4B,EAAE,cAAsB;IAC7H,MAAM,yBAAyB,GAAuB,OAAO,CAAC,cAAc,CAAC,kBAAkB,EAAE,MAAM,EAAE,WAAW,CAAC,IAAI,EAAE,CAAC;IAC5H,yBAAyB,CAAC,IAAI,CAAC;QAC3B,OAAO,EAAE,WAAW;QACpB,KAAK,EAAE,cAAc;KACxB,CAAC,CAAC;IACH,OAAO,CAAC,cAAc,CAAC,kBAAkB,EAAE,yBAAyB,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;AAC/F,CAAC,CAAC;AAEF;;;;;;GAMG;AACU,QAAA,QAAQ,GAAG,MAAM,CAAC,MAAW,EAAE,YAAoB,EAAE,UAAwC;IACtG,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC;IAChC,UAAU,CAAC,KAAK,GAAG,UAAe,GAAG,IAAW;;YAC5C,MAAM,iBAAiB,GAAuB,OAAO,CAAC,cAAc,CAAC,kBAAkB,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;YAC/G,EAAE,CAAC,CAAC,iBAAiB,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBACpD,GAAG,CAAC,CAAC,MAAM,gBAAgB,IAAI,iBAAiB,CAAC,CAAC,CAAC;oBAC/C,MAAM,WAAW,GAAG,IAAI,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC;oBAC/E,MAAM,WAAW,CAAC,QAAQ,EAAE,CAAC;gBACjC,CAAC;YACL,CAAC;YACD,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC9C,CAAC;KAAA,CAAC;IAEF,MAAM,CAAC,UAAU,CAAC;AACtB,CAAC,CAAC","sourcesContent":["// Copyright (c) 2017-2018, The Particl Market developers\n// Distributed under the GPL software license, see the accompanying\n// file COPYING or https://github.com/particl/particl-market/blob/develop/LICENSE\n\n/**\n * core.api.Validate\n * ------------------------------------------------\n *\n * Those annotations are used to simplify the use of request (payload)\n * validation. The '@Request(RequestBodyClass)' annotation defines the\n * the validation rules with his parameter and the '@Validate' runs all\n * the given validation classes.\n */\n\nimport 'reflect-metadata';\nimport { RequestBody } from './RequestBody';\nimport { MessageBody } from './MessageBody';\n\n\nconst requestMetadataKey = Symbol('ValidateRequest');\n\ninterface RequestParameter {\n    request: typeof RequestBody;\n    index: number;\n}\n\n/**\n * Request annotation marks the parameters, which should be validated as a RequestBody.\n *\n * @param request\n */\nexport const request = (requestBody: typeof RequestBody) => (target: object, propertyKey: string | symbol, parameterIndex: number): any => {\n    const existingRequestParameters: RequestParameter[] = Reflect.getOwnMetadata(requestMetadataKey, target, propertyKey) || [];\n    existingRequestParameters.push({\n        request: requestBody,\n        index: parameterIndex\n    });\n    Reflect.defineMetadata(requestMetadataKey, existingRequestParameters, target, propertyKey);\n};\n\n/**\n * Value annotation marks the parameters, which should be validated as a MessageBody.\n *\n * @param request\n */\nexport const message = (messageBody: typeof MessageBody) => (target: object, propertyKey: string | symbol, parameterIndex: number): any => {\n    const existingRequestParameters: RequestParameter[] = Reflect.getOwnMetadata(requestMetadataKey, target, propertyKey) || [];\n    existingRequestParameters.push({\n        request: messageBody,\n        index: parameterIndex\n    });\n    Reflect.defineMetadata(requestMetadataKey, existingRequestParameters, target, propertyKey);\n};\n\n/**\n * Validate annotation builds the given RequestBodies and validates them\n *\n * @param target\n * @param propertyName\n * @param descriptor\n */\nexport const validate = () => (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<any>): any => {\n    const method = descriptor.value;\n    descriptor.value = async function(...args: any[]): Promise<any> {\n        const requestParameters: RequestParameter[] = Reflect.getOwnMetadata(requestMetadataKey, target, propertyName);\n        if (requestParameters && requestParameters.length > 0) {\n            for (const requestParameter of requestParameters) {\n                const requestBody = new requestParameter.request(args[requestParameter.index]);\n                await requestBody.validate();\n            }\n        }\n        return method && method.apply(this, args);\n    };\n\n    return descriptor;\n};\n"]}